#include "EnemyPopCommand.h"
#include "BaseSystem/Logger/Logger.h"

EnemyPopCommand::EnemyPopCommand() {
}

EnemyPopCommand::~EnemyPopCommand() {
}

bool EnemyPopCommand::LoadFromCSV(const std::string& filePath) {
	// ファイルを開く
	std::ifstream file(filePath);
	if (!file.is_open()) {
		Logger::Log(Logger::GetStream(), "EnemyPopCommand: Failed to open file: " + filePath + "\n");
		return false;
	}

	// ストリームをクリア
	commandStream_.clear();
	commandStream_.str("");

	// エディタ用敵情報もクリア
	loadedEnemyInfos_.clear();

	// ファイルの内容を丸ごと文字列ストリームにコピー
	commandStream_ << file.rdbuf();

	// エディタ用に敵情報を解析して保存
	file.clear();
	file.seekg(0); // ファイルの先頭に戻る

	std::string line;
	int currentWaitTime = 0;

	while (std::getline(file, line)) {
		// 空行やコメント行をスキップ
		if (line.empty() || line.find("//") == 0) {
			continue;
		}

		std::istringstream lineStream(line);
		std::string command;
		std::getline(lineStream, command, ',');

		if (command == "WAIT") {
			// 待機コマンド
			std::string waitTimeStr;
			std::getline(lineStream, waitTimeStr, ',');
			currentWaitTime = std::atoi(waitTimeStr.c_str());
		} else if (command == "POP") {
			// 敵生成コマンド
			EditorEnemyInfo info;
			info.waitTime = currentWaitTime;
			currentWaitTime = 0; // リセット

			// 座標読み込み
			std::string xStr, yStr, zStr, typeStr, patternStr;
			std::getline(lineStream, xStr, ',');
			std::getline(lineStream, yStr, ',');
			std::getline(lineStream, zStr, ',');
			std::getline(lineStream, typeStr, ',');
			std::getline(lineStream, patternStr, ',');

			info.position.x = static_cast<float>(std::atof(xStr.c_str()));
			info.position.y = static_cast<float>(std::atof(yStr.c_str()));
			info.position.z = static_cast<float>(std::atof(zStr.c_str()));
			info.enemyType = StringToEnemyType(typeStr);
			info.pattern = StringToEnemyPattern(patternStr);

			loadedEnemyInfos_.push_back(info);
		}
	}

	// ファイルを閉じる
	file.close();

	Logger::Log(Logger::GetStream(), "EnemyPopCommand: Successfully loaded file: " + filePath + "\n");
	Logger::Log(Logger::GetStream(), "EnemyPopCommand: Loaded " + std::to_string(loadedEnemyInfos_.size()) + " enemy entries\n");
	return true;
}

bool EnemyPopCommand::GetNextCommand(EnemyPopCommandType& commandType, EnemyPopData& popData, WaitData& waitData) {
	std::string line;

	// コマンド実行ループ（コマンドは一行単位なので一行づつ取り出す）
	while (std::getline(commandStream_, line)) {
		// 一行分の文字列をストリームに変換して解析しやすくする
		std::istringstream lineStream(line);

		// 一行の中から[,]が現れるまでwordに入れる
		std::string word;
		// カンマ区切りで行の先頭文字列を取得
		std::getline(lineStream, word, ',');

		// "//"から始まる行はコメントなのでスキップ
		if (word.find("//") == 0) {
			continue;
		}

		// 空行をスキップ
		if (word.empty()) {
			continue;
		}

		// POPコマンド
		if (word.find("POP") == 0) {
			commandType = EnemyPopCommandType::POP;

			// x座標
			std::getline(lineStream, word, ',');
			popData.position.x = static_cast<float>(std::atof(word.c_str()));

			// y座標
			std::getline(lineStream, word, ',');
			popData.position.y = static_cast<float>(std::atof(word.c_str()));

			// z座標
			std::getline(lineStream, word, ',');
			popData.position.z = static_cast<float>(std::atof(word.c_str()));

			// 敵の種類
			std::getline(lineStream, word, ',');
			popData.enemyType = StringToEnemyType(word);

			// パターンの指定
			std::getline(lineStream, word, ',');
			popData.pattern = StringToEnemyPattern(word);

			return true;
		}
		// WAITコマンド
		else if (word.find("WAIT") == 0) {
			commandType = EnemyPopCommandType::WAIT;

			std::getline(lineStream, word, ',');
			// 待ち時間
			waitData.waitTime = atoi(word.c_str());

			return true;
		}
	}

	// コマンドが見つからない場合
	return false;
}

void EnemyPopCommand::Reset() {
	// ストリームの位置を先頭に戻す
	commandStream_.clear();
	commandStream_.seekg(0);
}

bool EnemyPopCommand::IsFinished() const {
	// ストリームの終端に達しているかチェック
	return commandStream_.eof();
}

std::vector<EditorEnemyInfo> EnemyPopCommand::GetAllEnemyInfo() const {
	return loadedEnemyInfos_;
}

bool EnemyPopCommand::SaveEnemyInfoToCSV(const std::string& filePath, const std::vector<EditorEnemyInfo>& enemyInfos) {
	std::ofstream file(filePath);
	if (!file.is_open()) {
		Logger::Log(Logger::GetStream(), "EnemyPopCommand: Failed to open file for writing: " + filePath + "\n");
		return false;
	}

	// ヘッダーコメントを書き込み
	file << "// Enemy Placement Data Generated by Editor\n";
	file << "// Format: COMMAND,X,Y,Z,TYPE,PATTERN or WAIT,TIME\n";
	file << "\n";

	// 敵配置データを書き込み
	for (const auto& info : enemyInfos) {
		// 待機コマンドを先に書き込み（0でない場合）
		if (info.waitTime > 0) {
			file << "WAIT," << info.waitTime << "\n";
		}

		// 敵生成コマンドを書き込み
		file << "POP,"
			<< info.position.x << ","
			<< info.position.y << ","
			<< info.position.z << ","
			<< EnemyTypeToString(info.enemyType) << ","
			<< EnemyPatternToString(info.pattern) << "\n";
	}

	file.close();
	Logger::Log(Logger::GetStream(), "EnemyPopCommand: Successfully saved " + std::to_string(enemyInfos.size()) + " enemy entries to " + filePath + "\n");
	return true;
}

EnemyType EnemyPopCommand::StringToEnemyType(const std::string& typeStr) {
	if (typeStr == "Normal" || typeStr == "0") {
		return EnemyType::Normal;
	} else if (typeStr == "RushingFish" || typeStr == "1") {
		return EnemyType::RushingFish;
	} else if (typeStr == "ShootingFish" || typeStr == "2") {
		return EnemyType::ShootingFish;
	}

	// デフォルトは通常の敵
	return EnemyType::Normal;
}

EnemyPattern EnemyPopCommand::StringToEnemyPattern(const std::string& patternStr) {
	if (patternStr == "Straight" || patternStr == "0") {
		return EnemyPattern::Straight;
	} else if (patternStr == "LeaveLeft" || patternStr == "1") {
		return EnemyPattern::LeaveLeft;
	} else if (patternStr == "LeaveRight" || patternStr == "2") {
		return EnemyPattern::LeaveRight;
	} else if (patternStr == "Homing" || patternStr == "3") {
		return EnemyPattern::Homing;
	} else if (patternStr == "Shooting" || patternStr == "4") {
		return EnemyPattern::Shooting;
	}

	// デフォルトは直進
	return EnemyPattern::Straight;
}

std::string EnemyPopCommand::EnemyTypeToString(EnemyType type) {
	switch (type) {
	case EnemyType::Normal: return "Normal";
	case EnemyType::RushingFish: return "RushingFish";
	case EnemyType::ShootingFish: return "ShootingFish";
	default: return "Normal";
	}
}

std::string EnemyPopCommand::EnemyPatternToString(EnemyPattern pattern) {
	switch (pattern) {
	case EnemyPattern::Straight: return "Straight";
	case EnemyPattern::LeaveLeft: return "LeaveLeft";
	case EnemyPattern::LeaveRight: return "LeaveRight";
	case EnemyPattern::Homing: return "Homing";
	case EnemyPattern::Shooting: return "Shooting";
	default: return "Straight";
	}
}